<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="/ovn-kubernetes/assets/css/style.css?v=9e6c62f21184b23c5bdbecd995abe5f149115b0f" media="screen" type="text/css">
    <link rel="stylesheet" href="/ovn-kubernetes/assets/css/print.css" media="print" type="text/css">

    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>NetworkPolicy | OVN-Kubernetes Homepage</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="NetworkPolicy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="test" />
<meta property="og:description" content="test" />
<link rel="canonical" href="http://www.ovn.org/ovn-kubernetes/networkpolicies/network-policy.html" />
<meta property="og:url" content="http://www.ovn.org/ovn-kubernetes/networkpolicies/network-policy.html" />
<meta property="og:site_name" content="OVN-Kubernetes Homepage" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="NetworkPolicy" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"test","headline":"NetworkPolicy","url":"http://www.ovn.org/ovn-kubernetes/networkpolicies/network-policy.html"}</script>
<!-- End Jekyll SEO tag -->


    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/ovn-kubernetes/favicon.ico" -->

<!-- end custom head snippets -->

  </head>

  <body>
    <header>
      <div class="inner">
        <a href="http://www.ovn.org/ovn-kubernetes/">
          <h1>OVN-Kubernetes Homepage</h1>
        </a>
        <h2>test</h2>
        
          <a href="https://github.com/ovn-org/ovn-kubernetes" class="button"><small>View project on</small> GitHub</a>
        
        
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1 id="networkpolicy">NetworkPolicy</h1>

<p>Kubernetes NetworkPolicy documentation: https://kubernetes.io/docs/concepts/services-networking/network-policies</p>

<p>Kubernetes NetworkPolicy API reference: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#networkpolicy-v1-networking-k8s-io</p>

<p>By default the network traffic from and to K8s pods is not restricted in any way. Using NetworkPolicy is a way to enforce network isolation of selected pods. When a pod is selected by a NetworkPolicy allowed traffic is specified by the <code class="language-plaintext highlighter-rouge">Ingress</code> and <code class="language-plaintext highlighter-rouge">Egress</code> sections.</p>

<p>Each NetworkPolicy object consists of four sections:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">podSelector</code>: a label selector that determines which pods the NetworkPolicy applies to</li>
  <li><code class="language-plaintext highlighter-rouge">policyTypes</code>: determines which policy types are included, if none are selected then <code class="language-plaintext highlighter-rouge">Ingress</code> will always be set and <code class="language-plaintext highlighter-rouge">Egress</code> will be set if any <code class="language-plaintext highlighter-rouge">Egress</code> rules are applied</li>
  <li><code class="language-plaintext highlighter-rouge">Ingress rules</code>: determines the sources that pods selected by the ingress rule can receive traffic from</li>
  <li><code class="language-plaintext highlighter-rouge">Egress rules</code>: determines the sinks that pods selected by the egress rule can send trafic to</li>
</ol>

<h1 id="networkpolicy-features">NetworkPolicy features</h1>

<p>These are described in order and are additive</p>

<h2 id="unicast-default-deny"><strong>Unicast default-deny</strong></h2>

<p>When a pod is selected by one or more NetworkPolicies, the <code class="language-plaintext highlighter-rouge">policyTypes</code> is set to both <code class="language-plaintext highlighter-rouge">Ingress</code> and <code class="language-plaintext highlighter-rouge">Egress</code>, and if no rules are specified it becomes isolated and all unicast ingress and egress traffic is blocked for pods in the same namespce as the NetworkPolicy.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
</code></pre></div></div>

<p>If only ingress traffic to all pods in a namespace needs to be blocked the following can be used</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
</code></pre></div></div>

<p>And finally if only Egress traffic from all pods in a Namespace needs to be blocked</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Egress
</code></pre></div></div>
<p><strong>OVN-Implementation:</strong></p>

<p>Every new NetworkPolicy creates a port group named <code class="language-plaintext highlighter-rouge">FOO_bar</code> where <code class="language-plaintext highlighter-rouge">FOO</code> is the policy’s Namespace and <code class="language-plaintext highlighter-rouge">bar</code> is the policy’s name.  All pods that the policy’s <code class="language-plaintext highlighter-rouge">podSelector</code> selects are added to the port group.</p>

<p>Additionally, two global deny PortGroups are also used, specifially: <code class="language-plaintext highlighter-rouge">IngressDefaultDeny</code> and <code class="language-plaintext highlighter-rouge">EgressDefaultDeny</code>.  Any pod selected by a NetworkPolicy in any Namespace is added to these PortGroups.</p>

<p>subset of <code class="language-plaintext highlighter-rouge">ovn-nbctl find port-group</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    _uuid               : 1deeac49-e87e-4e05-9324-beb8ef0dcef4
    acls                : [3f864884-cdb7-44be-a60e-e4f743afc9d0, f174fcf1-a7c2-496d-9b96-136aaccc014f]
    external_ids        : {name=ingressDefaultDeny}
    name                : ingressDefaultDeny
    ports               : [ce1bc4e5-0309-463f-9fd1-80f6e487e2d4]

    _uuid               : 5249b7a2-36bf-4246-98ea-13d5c5e17c68
    acls                : [36ed4154-71ab-4b8f-8119-5c4cc92708d9, c6663e29-99d0-4410-a2ff-f694a896a035]
    external_ids        : {name=egressDefaultDeny}
    name                : egressDefaultDeny
    ports               : []

</code></pre></div></div>

<p>Two ACLs (four total) are added to each PortGroup:</p>

<ol>
  <li>a drop policy with <code class="language-plaintext highlighter-rouge">priority=1000</code> and <code class="language-plaintext highlighter-rouge">direction=to-lport</code></li>
</ol>

<p>subset of <code class="language-plaintext highlighter-rouge">ovn-nbctl find ACL</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   _uuid               : f174fcf1-a7c2-496d-9b96-136aaccc014f
    action              : drop
    direction           : to-lport
    external_ids        : {default-deny-policy-type=Ingress}
    log                 : false
    match               : "outport == @ingressDefaultDeny"
    meter               : []
    name                : []
    priority            : 1000
    severity            : []


</code></pre></div></div>

<ol>
  <li>an allow policy for ARP traffic with <code class="language-plaintext highlighter-rouge">priority=1001</code>, <code class="language-plaintext highlighter-rouge">direction=to-lport</code>, and <code class="language-plaintext highlighter-rouge">match=arp</code></li>
</ol>

<p>subset of <code class="language-plaintext highlighter-rouge">ovn-nbctl find ACL</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_uuid               : 3f864884-cdb7-44be-a60e-e4f743afc9d0
action              : allow
direction           : to-lport
external_ids        : {default-deny-policy-type=Ingress}
log                 : false
match               : "outport == @ingressDefaultDeny &amp;&amp; arp"
meter               : []
name                : []
priority            : 1001
severity            : []

</code></pre></div></div>

<h2 id="applying-the-network-policy-to-specific-pods-using-specpodselector"><strong>Applying the network policy to specific pods using <code class="language-plaintext highlighter-rouge">spec.podSelector</code></strong></h2>

<p>In some cases only certain pods in a Namespace may need to be selected by a NetworkPolicy. To handle this feature the <code class="language-plaintext highlighter-rouge">spec.podSelector</code> field can be used as follows</p>

<p>The <code class="language-plaintext highlighter-rouge">spec.podSelector</code> is a label selector, which can be either a list of labels (<code class="language-plaintext highlighter-rouge">app=nginx</code>) or a match expression. Only pods in the same Namespace as the NetworkPolicy can be selected by it. The end result is a list of zero or more pods to which this NetworkPolicy’s <code class="language-plaintext highlighter-rouge">Ingress</code> and <code class="language-plaintext highlighter-rouge">Egress</code> sections will be applied.</p>

<p>For example, to block all traffic to and from a pod labeled with <code class="language-plaintext highlighter-rouge">app=demo</code> the following can be used</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector:
    matchLabels:
          app: demo
  policyTypes:
  - Ingress
  - Egress
</code></pre></div></div>

<h2 id="applying-ingress-and-egress-rules-using-specingress-and-specegress"><strong>Applying Ingress and Egress Rules using <code class="language-plaintext highlighter-rouge">spec.Ingress</code> and <code class="language-plaintext highlighter-rouge">spec.Egress</code></strong></h2>

<p>In some cases we need to explicilty define what sources and sinks a pod is allowed to communicate with, to handle this feature the <code class="language-plaintext highlighter-rouge">spec.Ingress</code> and <code class="language-plaintext highlighter-rouge">spec.Egress</code> fields of a NeworkPolicy can be used</p>

<p>These sections contain a list of ingress or egress “peers” (the <code class="language-plaintext highlighter-rouge">from</code> section for <code class="language-plaintext highlighter-rouge">ingress</code> and the <code class="language-plaintext highlighter-rouge">to</code> section for <code class="language-plaintext highlighter-rouge">egress</code>) and a list of IP ports/protocols (the <code class="language-plaintext highlighter-rouge">ports</code> section) to or from which traffic should be allowed. Each list element of each section is logically OR-ed with other elements.</p>

<p>Each <code class="language-plaintext highlighter-rouge">from</code>/<code class="language-plaintext highlighter-rouge">to</code> section can contain the following selectors</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">namespaceSelector</code>: a label selector matching all pods in zero or more Namespaces</li>
  <li><code class="language-plaintext highlighter-rouge">podSelector</code>: a label selector matching zero or more pods in the same Namespace as the NetworkPolicy</li>
  <li><code class="language-plaintext highlighter-rouge">namespaceSelector</code> and <code class="language-plaintext highlighter-rouge">podSelector</code>: when both are present in an element, selects only pods matching the <code class="language-plaintext highlighter-rouge">podSelector</code> from Namespaces matching the <code class="language-plaintext highlighter-rouge">namespaceSelector</code></li>
  <li><code class="language-plaintext highlighter-rouge">ipBlock</code>: an IP network in CIDR notation that can be either internal or external, with optional exceptions</li>
</ol>

<h3 id="specingress"><code class="language-plaintext highlighter-rouge">spec.ingress</code></h3>

<p>Rules defined in <code class="language-plaintext highlighter-rouge">spec.Ingress</code> can match on two main sections, 1.<code class="language-plaintext highlighter-rouge">spec.Ingress.from</code> and 2.<code class="language-plaintext highlighter-rouge">spec.Ingress.ports</code></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">spec.Ingress.from</code></p>

    <p>Specifies FROM what sources a network policy will allow traffic</p>

    <p>It contains three selectors which are described further below</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spec.Ingress.from.ipBlock</code></p>

        <p>The ip addresses from which to allow traffic, contains fields <code class="language-plaintext highlighter-rouge">spec.Ingress.from.ipBlock.cidr</code> to specify which ip address are allowed and 
  <code class="language-plaintext highlighter-rouge">spec.Ingress.from.ipBlock.except</code> to specifiy which address’s are not allowed</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spec.Ingress.from.namespaceSelector</code></p>

        <p>The Namespaces from which to allow traffic, uses matchLabels to select much like the <a href="#**Applying-the-network-policy-to-specific-pods-using-`spec.podSelector`**"><code class="language-plaintext highlighter-rouge">spec.Podselector</code> field</a></p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spec.Ingress.from.podSelector</code></p>

        <p>The pods from which to allow traffic, matches the same as described <a href="#**Applying-the-network-policy-to-specific-pods-using-`spec.podSelector`**">above</a></p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">spec.Ingress.ports</code></p>

    <p>The ports that the <code class="language-plaintext highlighter-rouge">Ingress</code> rule matches on, contains fields <code class="language-plaintext highlighter-rouge">spec.Ingress.ports.port</code> which can be either numerical or named, if set all port names and numbers will be matched, and <code class="language-plaintext highlighter-rouge">spec.Ingress.ports.protocol</code> matches to the protocol of the provided port</p>
  </li>
</ol>

<h3 id="specegress"><code class="language-plaintext highlighter-rouge">spec.egress</code></h3>

<p>Rules defined in <code class="language-plaintext highlighter-rouge">spec.Egress</code> can match on two main sections, 1.<code class="language-plaintext highlighter-rouge">spec.Egress.to</code> and 2.<code class="language-plaintext highlighter-rouge">spec.Egress.ports</code></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">spec.Egress.to</code></p>

    <p>specifies TO what destinations a network policy will allow a pod to send traffic</p>

    <p>It contains three selectors which are described further below</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spec.Egress.to.ipBlock</code></p>

        <p>The ip addresses which a pod can send traffic to, contains fields <code class="language-plaintext highlighter-rouge">spec.Egress.from.ipBlock.cidr</code> to specify which ip address are allowed and 
  <code class="language-plaintext highlighter-rouge">spec.Egress.from.ipBlock.except</code> to specifiy which address’s are not allowed</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spec.Egress.to.namespaceSelector</code></p>

        <p>The Namespaces allowed to receive traffic, uses matchLabels to select much like the <a href="#**Applying-the-network-policy-to-specific-pods-using-`spec.podSelector`**"><code class="language-plaintext highlighter-rouge">spec.Podselector</code> field</a></p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spec.Egress.to.podSelector</code></p>

        <p>The pods allowed to receive traffic, uses matchLabels to select much like described <a href="#**Applying-the-network-policy-to-specific-pods-using-`spec.podSelector`**"><code class="language-plaintext highlighter-rouge">spec.Podselector</code> field</a></p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">spec.Egress.ports</code></p>

    <p>The ports that the <code class="language-plaintext highlighter-rouge">Egress</code> rule matches on, contains fields <code class="language-plaintext highlighter-rouge">spec.Egress.ports.port</code> which can be either numerical or named, if set all port names and numbers will be matched, and <code class="language-plaintext highlighter-rouge">spec.Egress.ports.protocol</code> matches to the protocol of the provided port</p>
  </li>
</ol>

<h3 id="specingress-and-specegress-ovn-implementation"><code class="language-plaintext highlighter-rouge">spec.ingress</code> and <code class="language-plaintext highlighter-rouge">spec.egress</code> OVN implementation</h3>

<p>Each Namespace creates an AddressSet to which the IPs of all pods in that Namespace are added. This is used in NetworkPolicy <code class="language-plaintext highlighter-rouge">Ingress</code> and <code class="language-plaintext highlighter-rouge">Egress</code> sections to implement the Namespace selector.</p>

<p>Each element in the <code class="language-plaintext highlighter-rouge">from</code> or <code class="language-plaintext highlighter-rouge">to</code> list results in an AddressSet containing the IP addresses of all peer pods(i.e all pods touched by this policy) As pods are created, updated, or deleted each AddressSet is updated to add the new pod if it matches the selectors, or to remove the pod if it used to match selectors but no longer does. Namespace label changes may also result in AddressSet updates to add or remove pods if the Namespace now matches or no longer matches the <code class="language-plaintext highlighter-rouge">namespaceSelector</code>.</p>

<p>If an <code class="language-plaintext highlighter-rouge">ipBlock</code> is specified, an ACL with the label <code class="language-plaintext highlighter-rouge">ipblock_cidr="false"</code> is added to the policy’s PortGroup with <code class="language-plaintext highlighter-rouge">priority=1001</code> that allows traffic to or from the list of CIDRs in the <code class="language-plaintext highlighter-rouge">ipBlock</code>, any exceptions are added as <code class="language-plaintext highlighter-rouge">drop</code> ACLs to the policy’s PortGroup with <code class="language-plaintext highlighter-rouge">priority=1010</code>.</p>

<p><strong>Examples:</strong></p>

<p>Given two pods in Namespace <code class="language-plaintext highlighter-rouge">default</code> called  <code class="language-plaintext highlighter-rouge">client1</code> and <code class="language-plaintext highlighter-rouge">client2</code> , and one pod in Mamespace <code class="language-plaintext highlighter-rouge">demo</code>, called <code class="language-plaintext highlighter-rouge">server</code> lets make a network policy that allows ingress traffic to the server from <code class="language-plaintext highlighter-rouge">client1</code> but bocks traffic from <code class="language-plaintext highlighter-rouge">client2</code></p>

<p>Notice the pod <code class="language-plaintext highlighter-rouge">client1</code> and Namespace <code class="language-plaintext highlighter-rouge">default</code> are labeled with <code class="language-plaintext highlighter-rouge">app=demo</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [astoycos@localhost demo]$ kubectl get pods -o wide --show-labels --all-namespaces
  NAMESPACE            NAME                                        READY   STATUS    RESTARTS   AGE     IP           NODE                NOMINATED NODE   READINESS GATES   LABELS
  default              client1                                     1/1     Running   0          5m5s    10.244.2.5   ovn-worker          &lt;none&gt;           &lt;none&gt;            app=demo
  default              client2                                     1/1     Running   0          4m59s   10.244.1.4   ovn-worker2         &lt;none&gt;           &lt;none&gt;            &lt;none&gt;
  demo                 server                                      1/1     Running   0          42s     10.244.2.6   ovn-worker          &lt;none&gt;           &lt;none&gt;            &lt;none&gt;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [astoycos@localhost demo]$ kubectl get namespace --show-labels
  NAME                 STATUS   AGE   LABELS
  default              Active   94m   ns=default
  demo                 Active   66m   &lt;none&gt;
</code></pre></div></div>

<p>Before applying the following network policy both pods <code class="language-plaintext highlighter-rouge">client1</code> and <code class="language-plaintext highlighter-rouge">client2</code> can reach the <code class="language-plaintext highlighter-rouge">server</code> pod</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  apiVersion: networking.k8s.io/v1
  kind: NetworkPolicy
  metadata:
    name: allow-from-client
  spec:
    podSelector: {}
    policyTypes:
    - Ingress
    ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            ns: default
        podSelector:
          matchLabels:
            app: demo
</code></pre></div></div>

<p>after applying this Network policy in Namespace <code class="language-plaintext highlighter-rouge">demo</code> (<code class="language-plaintext highlighter-rouge">oc create -n demo -f policy.yaml</code>) only the pod <code class="language-plaintext highlighter-rouge">client1</code> can reach the <code class="language-plaintext highlighter-rouge">server</code> pod</p>

<p>NOTE: in the above definition there is only a single <code class="language-plaintext highlighter-rouge">from</code> element allowing connections from Pods labeled <code class="language-plaintext highlighter-rouge">app=demo</code> in Namespaces with the label <code class="language-plaintext highlighter-rouge">app=demo</code></p>

<p>if the from section was applied as follows</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - from:
      - namespaceSelector:
          matchLabels:
            ns: demo
      - podSelector:
          matchLabels:
            app: demo
</code></pre></div></div>
<p>Then there would be two elements in the <code class="language-plaintext highlighter-rouge">from</code> array which allows connections from Pods labeled <code class="language-plaintext highlighter-rouge">app=demo</code> <strong>OR</strong> and Pod from Namespaces with the label <code class="language-plaintext highlighter-rouge">app=demo</code></p>

<p>Now let’s have a look at some of the OVN resources that are created along with this Network Policy</p>

<p>For all worker nodes we can see the UUIDs of the logical ports corresponding to the pods <code class="language-plaintext highlighter-rouge">client1</code>, <code class="language-plaintext highlighter-rouge">client2</code>, and <code class="language-plaintext highlighter-rouge">server</code></p>

<p><strong>ovn-worker</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [root@ovn-control-plane ~]# ovn-nbctl lsp-list ovn-worker
  edb290cf-b250-4699-b102-7acbb6300dc9 (default_client1)
  c754a19d-1e8c-4415-99b9-66fdcdaed196 (demo_server)
  24c789a2-fc4b-42a5-bb16-5b1c19490b50 (k8s-ovn-worker)
  484b2004-a5c1-447c-b857-eb8e524a73f3 (kube-system_coredns-f9fd979d6-qp6xd)
  45163af0-08c2-4d42-9fc7-7b0ddc935bd8 (local-path-storage_local-path-provisioner-78776bfc44-lgzdf)
  0bb378f1-4e89-46a8-a455-7a891f64c7c8 (stor-ovn-worker)
</code></pre></div></div>
<p><strong>ovn-worker2</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [root@ovn-control-plane ~]# ovn-nbctl lsp-list ovn-worker2
  d5030b96-1163-4ed0-90f8-41b3831d2a0b (default_client2)
  4da8fb64-0a43-4d76-a7ba-18941c078862 (k8s-ovn-worker2)
  37f58eeb-8c1a-437b-8b21-bcc1337b2e3f (kube-system_coredns-f9fd979d6-628xd)
  65019041-51b2-4599-913d-7f01c8eaa394 (stor-ovn-worker2)
</code></pre></div></div>

<p><strong>Port Groups</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [root@ovn-control-plane ~]# ovn-nbctl find port-group
  _uuid               : 2b74086c-9986-4f4d-8c97-3388625230e9
  acls                : []
  external_ids        : {name=clusterPortGroup}
  name                : clusterPortGroup
  ports               : [24c789a2-fc4b-42a5-bb16-5b1c19490b50, 4da8fb64-0a43-4d76-a7ba-18941c078862, e556e329-d624-473a-8827-f022c17a8f60]

  _uuid               : a132ecce-dbca-4989-87f7-96e2f0b62a2c
  acls                : [b4e57f83-8b8f-4b37-b5e5-1f82704c49c4]
  external_ids        : {name=demo_allow-from-client}
  name                : a13757631697825269621
  ports               : [c754a19d-1e8c-4415-99b9-66fdcdaed196]

  _uuid               : a32d9dda-d7fb-4ae8-b6a9-3af17d62aa7f
  acls                : [510d797c-6302-4171-8a08-eeaab67063f4, f9079cce-29aa-4d1b-b36b-ca39933ad4e6]
  external_ids        : {name=ingressDefaultDeny}
  name                : ingressDefaultDeny
  ports               : [c754a19d-1e8c-4415-99b9-66fdcdaed196]

  _uuid               : 896a80ff-46f7-4837-a105-7b52cee0c625
  acls                : [660b10ea-0f2e-49cb-b620-ca4218e87ac6, 9bb634ff-cb69-44b6-a64d-09147cf337b5]
  external_ids        : {name=egressDefaultDeny}
  name                : egressDefaultDeny
  ports               : []
</code></pre></div></div>

<p>Notice that the port corresponding to the pod <code class="language-plaintext highlighter-rouge">server</code> is included in the <code class="language-plaintext highlighter-rouge">ingressDefaultDeny</code> port group</p>

<p>To bypass the ingress default deny and allow traffic from pod <code class="language-plaintext highlighter-rouge">client1</code> in Namespace <code class="language-plaintext highlighter-rouge">demo</code> as specificed in the network policy, an address set is created containing the ip address for the pod <code class="language-plaintext highlighter-rouge">client1</code></p>

<p>subset of <code class="language-plaintext highlighter-rouge">ovn-nbctl find address_set</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  _uuid               : 7dc68ee9-9628-4a6a-83f0-a92bfa0970c6
  addresses           : ["10.244.2.5"]
  external_ids        : {name=demo.allow-from-client.ingress.0_v4}
  name                : a14783882619065065142

</code></pre></div></div>

<p>Finally we can see the ingress ACL that allows traffic to the <code class="language-plaintext highlighter-rouge">server</code> pod by allowing <code class="language-plaintext highlighter-rouge">ip4.src</code> traffic <strong>FROM</strong> the address’s in the address set <code class="language-plaintext highlighter-rouge">a14783882619065065142</code> <strong>TO</strong> the port group <code class="language-plaintext highlighter-rouge">@a13757631697825269621</code> which contains the port <code class="language-plaintext highlighter-rouge">c754a19d-1e8c-4415-99b9-66fdcdaed196</code> (corresponding to the <code class="language-plaintext highlighter-rouge">server</code>’s logical port)</p>

<p>subset of <code class="language-plaintext highlighter-rouge">ovn-nbctl find ACL</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  _uuid               : b4e57f83-8b8f-4b37-b5e5-1f82704c49c4
  action              : allow-related
  direction           : to-lport
  external_ids        : {Ingress_num="0", ipblock_cidr="false", l4Match=None, namespace=demo, policy=allow-from-client, policy_type=Ingress}
  log                 : false
  match               : "ip4.src == {$a14783882619065065142} &amp;&amp; outport == @a13757631697825269621"
  meter               : []
  name                : []
  priority            : 1001
  severity            : []

</code></pre></div></div>

<p>TODO: Add more examples(good for first PRs), specifically replicate above scenario by matching on the pod’s network(<code class="language-plaintext highlighter-rouge">ip_block</code>) rather than the pod itself</p>


        </section>

        <aside id="sidebar">
          

          
            <p class="repo-owner"><a href="https://github.com/ovn-org/ovn-kubernetes">ovn-kubernetes</a> is maintained by <a href="https://github.com/ovn-org">ovn-org</a>.</p>
          

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</p>
        </aside>
      </div>
    </div>

  </body>
</html>
